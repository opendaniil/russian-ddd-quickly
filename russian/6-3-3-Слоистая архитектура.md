### Слоистая архитектура

![](../img/Image9.png)

Когда мы создаём программное приложение, большая часть его не напрямую связана с доменом, а относится к инфраструктуре или обслуживает само программное обеспечение. Нормально, что доменная часть приложения может быть довольно небольшой по сравнению с остальными, поскольку типичное приложение содержит много кода, связанного с доступом к базе данных, файловой или сетевой системой, пользовательскими интерфейсами и т.п.  

В объектно‑ориентированной программе, UI, база данных и другой вспомогательный код часто пишутся непосредственно в бизнес‑объектах. Дополнительная бизнес‑логика внедряется в поведение UI‑виджетов и скриптов базы данных. Это иногда происходит потому, что это самый простой способ быстро заставить всё работать.  

Однако когда доменная логика перемешана с кодом других слоёв, её становится чрезвычайно трудно увидеть и осмыслить. Поверхностные изменения в UI могут реально менять бизнес-логику. Изменение бизнес-правила может потребовать кропотливо прослеживать код интерфейса, работы с базой данных или другие части программы. Реализовать цельные объекты, отражающие модель, становится практически невозможно. Автоматизированное тестирование превращается в мучение. Когда в каждой операции смешаны технологии и логика разных уровней, программу приходится держать очень простой, иначе она становится непостижимой.

**Поэтому** разделяйте сложную программу на СЛОИ (LAYERS). Внутри каждого СЛОЯ выстраивайте цельное, связное проектирование, зависящее только от нижележащих слоёв. Используйте стандартные архитектурные приёмы, чтобы обеспечить слабую связанность с верхними слоями. Сосредоточьте весь код, относящийся к доменной модели, в одном слое и изолируйте его от кода пользовательского интерфейса, слоя приложения и инфраструктуры. Тогда доменные объекты, освобождённые от обязанностей отображать себя, сохранять себя, управлять прикладными задачами и так далее, смогут сосредоточиться на выражении доменной модели. Это позволяет модели развиваться: становиться достаточно богатой и достаточно ясной, чтобы фиксировать ключевое бизнес-знание и превращать его в работающий код.

Типичное архитектурное решение для domain‑driven designs включает четыре концептуальных слоя:  

- **Пользовательский Интерфейс / Слой Представления (User Interface / Presentation Layer)** – отвечает за представление информации пользователю и интерпретацию пользовательских команд.

- **Слой Приложения (Application Layer)** – тонкий слой, координирующий активность приложения. Не содержит бизнес‑логики. Не хранит состояние бизнес‑объектов, но он может хранить состояние выполнения прикладной задачи приложения (прогресса сценария).  

- **Слой Домена (Domain Layer)** – содержит знания о предметной области. Это ядро бизнес-приложения. Здесь сосредоточено состояние бизнес-объектов. При этом персистентность бизнес-объектов, то есть их сохранение и восстановление в нужном объёме, делегируется инфраструктурному слою.

- **Слой Инфраструктуры (Infrastructure Layer)** – служит поддерживающей библиотекой для всех остальных слоёв. Он обеспечивает взаимодействие между слоями, реализует персистентность бизнес-объектов, содержит вспомогательные компоненты для слоя пользовательского интерфейса и т.п. 

Важно разделять приложение на отдельные слои и устанавливать правила взаимодействия между ними. Если код не отделён по слоям достаточно чётко, он быстро переплетается так, что изменения становятся трудноуправляемыми. Одно простое изменение в одном месте может дать неожиданные и нежелательные последствия в другом. Доменный слой должен быть сосредоточен на ключевых вопросах предметной области и не должен заниматься инфраструктурными задачами. UI не должен быть жёстко связан ни с бизнес-логикой, ни с задачами, которые обычно относятся к инфраструктурному слою. Слой Приложения необходим во многих случаях: нужен “менеджер” над бизнес-логикой, который контролирует и координирует общую работу приложения.

Например, типичное взаимодействие слоёв приложения, домена и инфраструктуры может выглядеть так. Пользователь хочет забронировать маршрут перелёта и обращается к сервису в слое приложения. Слой приложения извлекает из инфраструктуры нужные доменные объекты и вызывает на них соответствующие методы, например чтобы проверить минимальные безопасные интервалы относительно уже запланированных рейсов. Когда доменные объекты выполнят все проверки и обновят свой статус до «подтверждено», сервис слоя приложения сохраняет эти объекты через инфраструктурный слой.