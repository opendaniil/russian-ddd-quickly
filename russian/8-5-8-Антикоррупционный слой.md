### Антикоррупционный слой

Мы часто сталкиваемся с ситуацией, когда создаём приложение, которому нужно взаимодействовать с legacy-системой или со сторонним приложением. Это ещё один вызов для архитектора модели домена. Многие legacy-приложения создавались без приёмов доменного моделирования, поэтому их модель запутана, тесно переплетена, её трудно понять и с ней трудно работать. Даже если она сделана хорошо, модель legacy-приложения мало полезна нам, потому что наша доменная модель, скорее всего, будет совсем другой. Тем не менее, между нашей моделью и legacy-моделью всё равно должен быть некоторый уровень интеграции, потому что использование старого приложения является одним из требований.

Есть разные способы, которыми наша клиентская система может взаимодействовать с внешней. Один это через сетевые соединения. Оба приложения должны использовать одни и те же протоколы сетевого взаимодействия, а клиент обязан соблюдать интерфейс, который использует внешняя система. Другой способ через базу данных. Внешняя система работает с данными, хранящимися в БД. Клиентская система должна обращаться к той же базе. В обоих случаях между системами передаются примитивные данные. С виду это достаточно просто, но на деле примитивные данные не содержат никакой информации о моделях. Мы не можем взять данные из базы и относиться к ним просто как к набору “примитивов”. За данными скрыто много семантики. Реляционная база данных хранит примитивные значения, связанные с другими примитивными значениями, образуя сеть отношений. Семантика данных крайне важна и её нужно учитывать. Клиентское приложение не может читать из базы и писать в неё, не понимая смысла используемых данных. Мы видим, что части внешней модели отражаются в базе данных и начинают проникать в нашу модель.

Есть риск, что внешняя модель начнёт деформировать нашу клиентскую модель, если мы это допустим. Мы не можем игнорировать взаимодействие с внешней моделью, но должны внимательно изолировать от неё свою собственную модель. Для этого нужно построить Антикоррупционный слой (Anticorruption Layer), который будет стоять между нашей клиентской моделью и внешней. С точки зрения нашей модели Антикоррупционный слой выглядит как естественная часть модели и не воспринимается как что то чужое. Он оперирует понятиями и действиями, знакомыми нашей модели. Но при этом Антикоррупционный слой общается с внешней моделью на её языке, а не на языке клиента. Этот слой работает как двунаправленный переводчик между двумя доменами и двумя языками. Главный результат в том, что клиентская модель остаётся чистой и непротиворечивой, не “загрязняясь” внешней.

Как реализовать Антикоррупционный слой (Anticorruption Layer)? Очень хороший подход — рассматривать этот слой как Сервис (Service) в модели клиента. Сервис удобно использовать, потому что он абстрагирует другую систему и позволяет обращаться к ней в наших терминах. Сервис выполнит нужный перевод, и наша модель останется изолированной. На уровне реализации такой Сервис будет оформлен как паттерн Фасад (Façade). (См. Design Patterns, Gamma etc 1995.) Кроме того, Антикоррупционному слою почти наверняка понадобится паттерн Адаптер (Adapter). Адаптер позволяет преобразовать интерфейс класса в тот, который понимает клиент. В нашем случае Адаптер не обязательно оборачивает класс, потому что его задача переводить между двумя системами.

![](../img/Image22.png)

Антикоррупционный слой может содержать несколько Сервисов. Для каждого Сервиса есть соответствующий Фасад (Façade), и для каждого Фасада мы добавляем **Адаптер (Adapter)**. Не стоит использовать один Адаптер на все Сервисы, иначе он захламится смешанной функциональностью.

Нужно добавить ещё один компонент. Адаптер отвечает за инкапсуляцию поведения внешней системы. Но нам также требуется преобразование объектов и данных. Для этого используется транслятор. Это может быть очень простой объект с небольшой функциональностью, который решает базовую задачу перевода данных. Если у внешней системы сложный интерфейс, может быть лучше добавить дополнительный Фасад между адаптерами и этим интерфейсом. Это упростит протокол Адаптера и сильнее отделит его от другой системы.