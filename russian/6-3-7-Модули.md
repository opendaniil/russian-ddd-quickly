### Модули  

Для большого и сложного приложения модель со временем растёт всё больше. Модель достигает такой сложности, что её трудно рассматривать как единое целое, а понимание взаимосвязей и взаимодействий между различными частями становится затруднительным. Поэтому необходимо организовать модель в модули. Модули служат способом организации связанных концепций и задач с целью снижения сложности.  

Модули широко применяются в большинстве проектов. Проще получить представление о большой модели, если смотреть на её модули, а затем на взаимосвязи между ними. После того как взаимодействие между модулями понято, можно приступить к деталям внутри конкретного модуля. Это простой и эффективный способ управления сложностью.  

Ещё одна причина использовать модули связана с качеством кода. Широко признано, что программный код должен обладать высокой сцепленностью (high cohesion) и низкой связанностью (low coupling). Хотя сцепленность обычно рассматривают на уровне классов и методов, тот же принцип применим и на уровне модулей. Поэтому рекомендуется объединять тесно связанные классы в модули, чтобы добиться максимально возможной сцепленности. Различают несколько типов сцепленности. Два наиболее распространённых это коммуникационная сцепленность (communicational cohesion) и функциональная сцепленность (functional cohesion). Коммуникационная сцепленность достигается, когда части модуля работают с одним и тем же набором данных. В таком случае их имеет смысл держать вместе, потому что их связь обусловлена общими данными. Функциональная сцепленность достигается, когда все части модуля совместно выполняют одну чётко определённую задачу. Это считается лучшим видом сцепленности.

Использование модулей при построении системы позволяет повысить сцепленность (cohesion) и снизить связанность (coupling). Модули должны состоять из элементов, которые функционально или логически относятся друг к другу, тем самым обеспечивая сцепленность. У модулей должны быть чётко определённые интерфейсы, через которые к ним обращаются другие модули. Вместо того чтобы вызывать три объекта внутри модуля, лучше обращаться к одному интерфейсу, потому что это снижает связанность. Низкая связанность уменьшает сложность и повышает поддерживаемость. Систему проще понять, когда между модулями, выполняющими чётко определённые задачи, мало связей, чем когда каждый модуль имеет множество связей со всеми остальными.

Выбирайте модули, которые рассказывают историю системы и содержат согласованный набор концепций. Это часто приводит к низкой связности между модулями, но если это не так, ищите способ изменить модель, чтобы распутать концепции, или обнаружьте упущенную концепцию, которая может стать основой модуля, объединяющего элементы в осмысленном виде. Стремитесь к низкой связности в том смысле, чтобы концепции можно было понимать и обсуждать независимо друг от друга. Уточняйте модель, пока она не начнёт естественно разделяться по верхнеуровневым доменным концепциям, и пока соответствующий код также не окажется развязанным.

Давайте модулям имена, которые становятся частью Единого языка. Модули и их названия должны отражать понимание домена.

Проектировщики привыкли выделять модули с самого начала. Это обычная часть того, как мы строим системы. После того как роль модуля определена, она обычно остаётся неизменной, даже если внутреннее устройство модуля со временем сильно меняется. Рекомендуется сохранять гибкость и позволять модулям эволюционировать вместе с проектом, а не “замораживать” их. Да, рефакторинг модуля может быть дороже, чем рефакторинг класса, но когда обнаруживается ошибка в модульном разбиении, лучше исправить её изменением модуля, чем пытаться обходить проблему костылями.