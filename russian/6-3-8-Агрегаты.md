### Агрегат  

Последние три паттерна в этой главе касаются иной задачи моделирования, связанной с жизненным циклом доменных объектов. Доменные объекты проходят набор состояний в течение своей жизни. Они создаются, помещаются в память и используются в вычислениях, а затем уничтожаются. В некоторых случаях они сохраняются в постоянных хранилищах, например в базе данных, откуда могут быть извлечены позже, или архивируются. В какой‑то момент они могут быть полностью удалены из системы, включая базу данных и архивное хранилище.  

Управление жизненным циклом доменного объекта — отдельная задача, и если её выполнить неправильно, это может негативно сказаться на доменной модели. Мы представим три паттерна, которые помогают с этим справиться. Агрегат это доменный паттерн, который используется для определения владения объектами и границ. Фабрики и Репозитории это два паттерна проектирования, которые помогают нам с созданием и хранением объектов. Начнём с разговора об Агрегатах.

Модель может содержать большое количество доменных объектов. Сколько бы внимания мы ни уделяли проектированию, всё равно бывает так, что многие объекты оказываются ассоциированы друг с другом, образуя сложную сеть отношений. Существует несколько типов ассоциаций. Для каждой проходимой ассоциации в модели должен существовать соответствующий программный механизм, который её обеспечивает. Реальные ассоциации между доменными объектами в итоге оказываются в коде и часто даже в базе данных. Связь один-к-одному между клиентом и банковским счётом, открытым на его имя, выражается ссылкой между двумя объектами и подразумевает отношение между двумя таблицами базы данных: той, где хранятся клиенты, и той, где хранятся счета.

Трудность моделирования чаще всего не в том, чтобы сделать модель достаточно полной, а в том, чтобы сделать её максимально простой и понятной. В большинстве случаев разумно убирать связи из модели или упрощать их, если только они не отражают действительно глубокое понимание предметной области.  

Ассоциация один-ко-многим сложнее, потому что она связывает один объект с множеством других. Иногда её можно упростить, превратив в ассоциацию между одним объектом и коллекцией других объектов, хотя это возможно не всегда.

Существуют ассоциации «многие-ко-многим», и значительная часть из них двунаправленные. Это сильно увеличивает сложность и делает управление жизненным циклом таких объектов довольно трудным. Число ассоциаций нужно сокращать настолько, насколько это возможно. Во-первых, ассоциации, которые не являются существенными для модели, следует убрать. В предметной области они могут существовать, но в нашей модели они не нужны, значит убираем. Во-вторых, кратность можно уменьшить, добавив ограничение. Если сейчас одной и той же связи соответствуют многие объекты, то при правильно заданном ограничении может оказаться, что достаточно одного. В-третьих, двунаправленные ассоциации часто можно превратить в однонаправленные. У каждой машины есть двигатель, и у каждого двигателя есть машина, в которой он работает. Связь двунаправленная, но её легко упростить, если считать, что двигатель есть у машины, а не наоборот.

После того как мы сократим и упростим ассоциации между объектами, у нас всё равно может остаться множество отношений. Банковская система хранит и обрабатывает данные клиентов. Эти данные включают персональную информацию клиента, такую как имя, адрес, номера телефонов, род занятий, а также данные по счетам: номер счёта, баланс, проведённые операции и т.д. Когда система архивирует или полностью удаляет информацию о клиенте, она должна убедиться, что удалены все ссылки. Если такие ссылки хранятся во многих объектах, трудно гарантировать, что убраны они все. Кроме того, когда какие-то данные клиента меняются, система должна обеспечить, чтобы изменения корректно отразились по всей системе и целостность данных сохранялась. Обычно это оставляют на уровне базы данных. Для обеспечения целостности данных используются транзакции. Но если модель спроектирована недостаточно аккуратно, возникнет высокая конкуренция за блокировки в базе данных, и производительность упадёт. Хотя транзакции базы данных играют ключевую роль в таких операциях, желательно решать часть проблем, связанных с целостностью данных, прямо на уровне модели.

Также необходимо уметь обеспечивать соблюдение инвариантов. Инварианты это правила, которые должны сохраняться всякий раз, когда данные изменяются. Это трудно реализовать, когда многие объекты хранят ссылки на изменяемые объекты данных.

В модели со сложными ассоциациями трудно гарантировать согласованность изменений объектов. Часто инварианты относятся к тесно связанным объектам, а не только к отдельным, изолированным. Но чрезмерно осторожные схемы блокировок приводят к тому, что множество пользователей без необходимости мешают друг другу, и система становится непригодной к работе.

Поэтому используйте Агрегаты. Агрегат это группа ассоциированных объектов, которая при изменениях данных рассматривается как единое целое. Агрегата имеет границу, отделяющую объекты внутри от объектов снаружи. У каждого Агрегата есть один корень. Корень это Сущность, и это единственный объект, к которому можно обращаться извне. Корень может хранить ссылки на любые объекты агрегата, остальные объекты могут хранить ссылки друг на друга, но извне можно держать ссылку только на корень. Если внутри границы есть другие сущности, их идентичность локальна и имеет смысл только внутри агрегата.

Как Агрегат обеспечивает целостность данных и соблюдение инвариантов? Поскольку другие объекты могут хранить ссылки только на корень, это означает, что они не могут напрямую изменять остальные объекты внутри агрегата. Всё, что они могут сделать, это изменить корень или попросить корень выполнить какие-то действия. И корень сможет изменять другие объекты, но это будет операция, происходящая внутри агрегата, и её можно контролировать. Если корень удалён и убран из памяти, все остальные объекты агрегата тоже будут удалены, потому что больше нет ни одного объекта, который держал бы на какой-либо из них ссылку. Когда в корне выполняется изменение, которое косвенно затрагивает другие объекты агрегата, обеспечить соблюдение инвариантов просто, потому что это сделает корень. Гораздо сложнее сделать это, когда внешние объекты имеют прямой доступ к внутренним и изменяют их. В такой ситуации обеспечение соблюдения инвариантов означает, что придётся разместить часть логики во внешних объектах, чтобы с этим справляться, а это нежелательно.

Корень может передавать внешним объектам временные ссылки на внутренние объекты, при условии, что внешние объекты не будут удерживать эту ссылку после завершения операции. Один простой способ сделать это — передавать внешним объектам копии объектов-значений. На самом деле неважно, что будет происходить с этими объектами, потому что это никак не повлияет на целостность агрегата.

Если объекты Агрегата хранятся в базе данных, только корень должен быть доступен через запросы. Другие объекты следует получать через проходящие ассоциации.  

Объекты внутри Агрегата могут хранить ссылки на корни других Агрегатов.  

Корень Сущности имеет глобальную идентичность и отвечает за поддержание инвариантов. Внутренние Сущности имеют локальную идентичность.  

Сгруппируйте Сущности и Объекты-значения в Агрегаты и определите границы вокруг каждого. Выберите одну Сущность в качестве корня каждого Агрегата и контролируйте весь доступ к объектам внутри границы через корень. Разрешите внешним объектам хранить ссылки только на корень. Временные ссылки на внутренних участников можно передавать наружу только для использования в рамках одной операции. Поскольку корень контролирует доступ, его нельзя застать врасплох изменениями внутренних объектов. Такая организация делает практичным обеспечение всех инвариантов для объектов внутри Агрегата и для Агрегата в целом при любом изменении состояния.

Простой пример Агрегата показан на следующей диаграмме. Клиент является корнем Агрегата, а все остальные объекты — внутренние. Если требуется адрес, внешним объектам можно передать его копию.

![](../img/Image11.png)