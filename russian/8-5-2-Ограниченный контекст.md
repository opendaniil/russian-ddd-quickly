### Ограниченный контекст

У каждой доменной модели есть свой контекст. Когда мы работаем с одной моделью, контекст неявен. Его не нужно отдельно определять. Но когда мы создаём приложение, предназначенное для интеграции с другим ПО, например с легаси-системой, очевидно, что у нового приложения своя модель и свой контекст, отделённые от легаси-модели и её контекста. Их нельзя объединять, смешивать или путать. А вот в большом корпоративном приложении контекст нужно явно определить для каждой создаваемой модели.

В любом крупном проекте одновременно живут несколько моделей. Но когда код, опирающийся на разные модели, начинают смешивать, система становится багнутой, ненадёжной и трудной для понимания. Коммуникация между участниками команды тоже начинает буксовать. Часто оказывается непонятно, в каком контексте эта модель применима.

Не существует формулы, по которой одну большую модель можно правильно нарезать на меньшие. Старайтесь собирать в одну модель элементы, которые связаны между собой и складываются в естественную концепцию. Модель должна быть достаточно небольшой, чтобы её можно было отдать одной команде. Тогда взаимодействие и коммуникация внутри команды становятся более плавными и полноценными, что помогает разработчикам, работающим над одной моделью. Контекст модели это набор условий, которые нужно зафиксировать, чтобы термины внутри модели имели строго определённый смысл.

Главная идея это определить область ответственности модели, очертить границы её контекста и дальше делать всё возможное, чтобы модель оставалась цельной. Сложно сохранить модель чистой, когда она размазана по всему корпоративному проекту, и гораздо проще, когда она ограничена конкретной областью. Явно зафиксируйте контекст, в рамках которого эта модель применима. Явно проведите границы через организацию команд, использование в конкретных частях приложения и физических артефактах вроде кодовых баз и схем БД. Внутри этих границ держите модель строго согласованной, а внешние вопросы не должны вас отвлекать или запутывать.

Ограниченный контекст (Bounded Context) это не Модуль. Ограниченный контекст задаёт логическую рамку, внутри которой развивается модель. Модули используют для организации элементов модели, поэтому Ограниченный контекст включает в себя Модуль.

Когда разным командам приходится работать с одной и той же моделью, нужно быть очень осторожными, чтобы не мешать друг другу. Нужно постоянно помнить, что изменения в модели могут сломать уже работающую функциональность. Если же используется несколько моделей, каждый может свободно работать над своей частью. Все знают границы своей модели и остаются внутри них. Остаётся только следить, чтобы модель сохранялась чистой, согласованной и цельной. Каждая модель намного легче выдерживает рефакторинг без последствий для других моделей. Архитектурное решение можно уточнять и дистиллировать, чтобы добиться максимальной чистоты.

За наличие нескольких моделей приходится платить. Нужно определить границы и отношения между разными моделями. Это требует дополнительной работы и усилий по проектированию и возможно, понадобится некоторый перевод между моделями. Мы не сможем переносить объекты из одной модели в другую и не сможем свободно вызывать поведение так, будто границ не существует. Но это не слишком сложная задача, и выгоды стоят этих усилий.

Например, мы хотим создать e-commerce приложение для продажи товаров в интернете. Это приложение позволяет клиентам регистрироваться, и мы собираем их персональные данные, включая номера кредитных карт. Данные хранятся в реляционной БД. Клиенты могут входить в систему, просматривать сайт в поисках товаров и оформлять заказы. Приложению нужно будет публиковать доменное событие каждый раз, когда заказ оформлен, потому что кому-то придётся отправить запрошенный товар. Мы также хотим построить интерфейс отчётности для формирования отчётов, чтобы отслеживать статус доступных товаров, что клиенты хотят купить, что им не нравится, и так далее. В начале мы стартуем с одной модели, которая покрывает весь домен e-commerce. Это кажется соблазнительным, потому что, в конце концов, от нас требуется сделать одно большое приложение. Но если внимательнее посмотреть на задачу, выясняется, что приложение интернет-магазина на самом деле не связано с приложением отчётности. У них разные задачи, они оперируют разными понятиями и могут даже требовать разных технологий. Единственное, что у них действительно общее это данные о клиентах и товарах, которые лежат в базе и что оба приложения к ним обращаются.

Рекомендуемый подход это выделить отдельную модель для каждого домена: одну для e-commerce и одну для отчётности. Обе модели могут развиваться свободно, почти не завися друг от друга, и даже со временем стать отдельными приложениями. Возможно, приложению отчётности понадобятся какие-то специфические данные, которые e-commerce приложение должно сохранять в базе данных, но в остальном они могут расти независимо.

Нужна система обмена сообщениями, чтобы уведомлять сотрудников склада об оформленных заказах, чтобы они могли отправлять купленные товары. Сотрудники, отвечающие за отправку, будут пользоваться приложением, которое даёт им подробную информацию о купленном товаре, количестве, адресе клиента и требованиях к доставке. Нет необходимости, чтобы модель интернет-магазина покрывала оба домена деятельности. Гораздо проще, если приложение интернет-магазина будет отправлять на склад Объекты-значения с информацией о покупке через асинхронный обмен сообщениями. Здесь явно две модели, которые можно разрабатывать отдельно, и нам нужно лишь убедиться, что интерфейс между ними работает корректно.