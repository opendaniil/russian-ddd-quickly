## Единый язык

### Необходимость общего языка  

В предыдущей главе было доказано, что абсолютно необходимо разрабатывать модель домена, заставляя специалистов по программному обеспечению работать с экспертами домена; однако такой подход обычно сталкивается с начальными трудностями из‑за фундаментального барьера коммуникации. Разработчики мыслят в терминах классов, методов, алгоритмов, шаблонов и постоянно пытаются сопоставить реальное понятие с программным артефактом. Они хотят увидеть, какие классы объектов создать и какие отношения смоделировать между ними. Они думают о наследовании, полиморфизме, OOP и т.п. И постоянно так говорят. И это нормально для них. Разработчики будут разработчиками. Но эксперты домена обычно ничего об этом не знают. Обычно они не знакомы ни с библиотеками и фреймворками, ни с механизмами хранения данных, а во многих случаях и с базами данных. Они знают только свою предметную область.

В примере мониторинга воздушного движения эксперты домена знают о самолетах, маршрутах, высотах, долготе и широте, об отклонениях от заданного маршрута, о траекториях полёта. И они говорят об этом своим жаргоном, который иногда трудно понять постороннему.  

Чтобы преодолеть эту разницу в стиле общения, при построении модели мы должны обмениваться идеями о модели, о её элементах, о том, как их соединять, что важно, а что нет. Коммуникация на этом уровне имеет решающее значение для успеха проекта. Если один говорит что‑то, а другой не понимает или, что ещё хуже, понимает иначе, каковы шансы проекта на успех?  

Проект сталкивается с серьёзными проблемами, когда участники команды не разделяют общий язык для обсуждения предметной области. Эксперты домена используют свой профессиональный жаргон, а технические специалисты — свой язык, заточенный под обсуждение домена в терминах проектирования системы (архитектуры и модели).

Термины, которыми пользуются в повседневных обсуждениях, не совпадают с терминологией, закреплённой в коде (который в итоге становится основным артефактом проекта). Даже один и тот же человек использует разные формулировки в устной и письменной коммуникации, из-за чего наиболее точные выражения домена часто так и остаются неформализованными и не попадают ни в код, ни в документы.

Во время этих сессий общения часто используется перевод, чтобы другие поняли, о чём идёт речь. Разработчики могут пытаться объяснить некоторые шаблоны проектирования простым языком, иногда без успеха. Эксперты домена будут стремиться донести свои идеи, вероятно, создавая новый жаргон. В процессе коммуникация страдает, и такой перевод не помогает формированию общего понимания.  

Мы склонны использовать свои диалекты во время этих сессий проектирования, но ни один из этих диалектов не может стать общим языком, потому что ни один не удовлетворяет потребности всех.  

Нам определённо нужно говорить на одном языке, когда мы встречаемся, чтобы обсудить модель и определить её. Каким будет этот язык? языком разработчиков? языком экспертов домена? Чем‑то промежуточным?  

Ключевой принцип domain‑driven design — использовать язык, основанный на модели. Поскольку модель является общей площадкой, местом встречи программного обеспечения и домена, уместно использовать её как основу для этого языка.  

Используйте модель как основу языка. Требуйте, чтобы команда последовательно использовала язык во всех коммуникациях, а также в коде. Пока команда делится знаниями и оттачивает модель, она использует речь, письмо и диаграммы. Убедитесь, что этот язык последовательно присутствует во всех формах коммуникации, используемых командой; по этой причине язык называется Единый язык.  

Единый язык связывает все части модели и проектирования и создаёт основу для слаженной работы команды. Чтобы в крупном проекте оформились архитектурные и проектные решения, уходят недели и даже месяцы. По ходу работы команда обнаруживает, что некоторые исходные понятия были неверны или использовались неуместно, а также выявляет новые элементы, которые нужно учесть и встроить в общую картину. Всё это невозможно без общего языка.

язык не появляется за одну ночь. Чтобы вытащить на поверхность его ключевые элементы, нужны усилия и концентрация. Мы должны найти главные понятия предметной области и то, как мы строим её модель, дать этим понятиям имена и начать пользоваться ими везде. Часть терминов видна сразу, а часть приходится добывать.

Устраняйте трудности, экспериментируя с альтернативными выражениями, отражающими альтернативные модели. Затем рефакторьте код, переименовывая классы, методы и модули в соответствии с новой моделью. Разрешайте путаницу в терминах в разговоре так же, как приходите к согласию по значению обычных слов.  

Создание такого языка имеет очевидный результат: модель и язык тесно взаимосвязаны. Изменение языка должно приводить к изменению модели.  

Эксперты предметной области должны возражать против терминов и структур, которые звучат неестественно или плохо передают понимание домена. Если экспертам домена что-то непонятно в модели или в языке, скорее всего, с ними что-то не так. Со своей стороны разработчики должны следить за двусмысленностью и несогласованностью, которые имеют свойство просачиваться в проектирование.

### Создание Единого языка  

Как начать построение языка? Ниже гипотетический диалог между разработчиком и экспертом домена в проекте мониторинга воздушного движения. Обратите внимание на слова, выделенные полужирным.  

Developer: Мы хотим мониторить воздушное движение. С чего начнём?  

Expert: Начнём с основ. Всё это движение состоит из самолётов. Каждый самолёт взлетает из места отправления и приземляется в месте назначения.  

Developer: Понятно. Когда он летит, самолёт может просто выбрать любой воздушный путь, который нравится пилотам? Это им решать, какой путь выбрать, пока они доберутся до назначения?  

Expert: О нет. Пилоты получают маршрут, который они должны следовать. И они должны держаться этого маршрута как можно ближе.  

Developer: Я представляю этот маршрут как 3D путь в воздухе. Если использовать декартову систему координат, то маршрут — просто серия 3D точек.  

Expert: Не думаю. Мы не видим маршрут так. Маршрут — это проекция на землю ожидаемого воздушного пути самолёта. Маршрут проходит через серию точек на земле, определённых их широтой и долготой.  

Developer: Хорошо, тогда назовём каждую из этих точек fix, потому что это фиксированная точка поверхности Земли. И будем использовать серию 2D точек (2DPoint) для описания пути. Кстати, отправление и назначение — тоже fix. Не стоит рассматривать их как отдельные концепции. Маршрут достигает назначения, как достигает любой другой fix. Самолёт должен следовать маршруту, но значит ли это, что он может лететь на любой высоте, насколько хочет?

Expert: Нет. Высота, которую самолёт должен иметь в определённый момент, также фиксируется в плане полёта (Flight Plan).  

Developer: План полёта? Что это?  

Expert: Перед вылетом из аэропорта пилоты получают детальный план полёта, который включает всевозможную информацию о полёте: маршрут (route), крейсерскую высоту, крейсерскую скорость, тип самолёта, даже сведения о членах экипажа.  

Developer: Хм, план полёта кажется довольно важным. Давайте включим его в модель.

![](../img/Image6.png)

Developer: Так лучше. Теперь, глядя на это, я понимаю одну вещь. Когда мы мониторим воздушное движение, нас интересует не сами самолёты — их цвет, марка Boeing или Airbus. Нас интересует их полёт. Именно это мы отслеживаем и измеряем. Думаю, нам стоит немного изменить модель, чтобы быть точнее.  

Обратите внимание, как эта команда, обсуждая домен мониторинга воздушного движения и свою начальную модель, постепенно создаёт язык, состоящий из слов, выделенных полужирным. Также заметим, как этот язык меняет модель!  

Однако в реальной жизни такой диалог гораздо более многословен, люди часто говорят косвенно, вдаются в детали или выбирают неверные концепции; это делает создание языка сложным. Чтобы начать решать эту проблему, все члены команды должны осознавать необходимость создания общего языка и помнить о фокусе на сущностном, используя язык по мере необходимости. Мы должны минимизировать использование собственного жаргона в таких сессиях и применять Единый язык, потому что это помогает общаться ясно и точно.  

![](../img/Image7.png)

Также настоятельно рекомендуется разработчикам реализовать основные концепции модели в коде. Можно написать класс Route и другой класс Fix. Класс Fix может наследоваться от класса 2DPoint, либо содержать 2DPoint как основной атрибут. Это зависит от других факторов, которые будут обсуждены позже. Создавая классы для соответствующих концепций модели, мы сопоставляем модель и код, а также язык и код. Это очень полезно, так как делает код более читаемым и воспроизводит модель. Выражение модели в коде окупается позже в проекте, когда модель становится большой, а изменения в коде могут иметь нежелательные последствия, если код был спроектирован неправильно.  

Мы видели, как язык разделяется всей командой и как он помогает строить знания и создавать модель. Что мы должны использовать в качестве языка? Только на словах? Мы использовали диаграммы. Что ещё? Текст?  

Некоторые могут сказать, что UML достаточно хорош для построения модели. И действительно, это отличный инструмент для записи ключевых концепций как классов и выражения их отношений. Можно нарисовать четыре‑пять классов на листе, записать их имена и показать их взаимосвязи. Всем легко понять, что вы думаете, а графическое выражение идеи легко воспринимается. Все сразу делятся одной визуальной картиной по определённой теме, и общение становится проще. Когда появляются новые идеи, диаграмма изменяется, отражая концептуальное изменение.  

UML диаграммы очень полезны, когда количество элементов небольшое. Но UML может разрастаться, как грибы после летнего дождя. Что делать, когда у вас сотни классов, заполняющих лист бумаги длиной как река Миссисипи? Даже разработчикам сложно их читать, не говоря уже о экспертах домена. Они не поймут многое, когда диаграмма становится большой, и это происходит даже в проектах среднего размера.  

Кроме того, UML хорошо выражает классы, их атрибуты и отношения, но поведение классов и ограничения выражаются не так просто. Для этого UML использует текстовые заметки, помещённые в диаграмму. Поэтому UML не может передать два важных аспекта модели: смысл представляемых концепций и то, что объекты должны делать. Но это нормально, мы можем добавить другие инструменты коммуникации.  

Мы можем использовать документы. Один из рекомендуемых способов коммуникации модели — создавать небольшие диаграммы, каждая из которых содержит подмножество модели. Такие диаграммы включают несколько классов и их отношения, уже охватывая большую часть концепций. Затем к диаграмме можно добавить текст, объясняющий поведение и ограничения, которые диаграмма не может передать. Каждый такой раздел пытается объяснить один важный аспект домена, освещая отдельную часть.  

Эти документы могут быть даже нарисованы от руки, потому что это передаёт ощущение временности и возможности изменения в ближайшем будущем, что действительно так, поскольку модель меняется много раз в начале, прежде чем достичь более стабильного состояния.  

Может возникнуть искушение создать одну большую диаграмму всей модели. Однако чаще всего такие диаграммы почти невозможно собрать. И даже если вам удастся сделать единый рисунок, он будет настолько загромождён, что не передаст понимание лучше, чем набор небольших диаграмм.  

Будьте осторожны с длинными документами. На их написание уходит много времени, и они могут устареть ещё до завершения. Документы должны быть синхронны с моделью. Старые документы, использующие неправильный язык и не отражающие модель, мало полезны. Старайтесь избегать их, когда это возможно.  

Также возможно общаться через код. Этот подход широко поддерживается сообществом XP(Extreme Programming). Хорошо написанный код может быть очень коммуникативным. Хотя поведение, выраженное методом, ясно, так ли же ясно название метода, как и его тело? Утверждения тестов «говорят сами за себя», но как насчёт имён переменных и общей структуры кода? Рассказывают ли они всю историю, громко и ясно? Функционально правильный код не обязательно выражает правильную идею. Писать модель в коде очень сложно.  

Есть и другие способы коммуникации в процессе проектирования. Эта книга не ставит целью описать их все. Однако одно очевидно: команде, состоящей из архитекторов, разработчиков и экспертов предметной области, нужен язык, который объединяет их работу и помогает им формировать модель и выражать её в коде.