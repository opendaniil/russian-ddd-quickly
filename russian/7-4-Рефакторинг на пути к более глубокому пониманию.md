## Рефакторинг на пути к более глубокому пониманию

### Непрерывный рефакторинг

До сих пор мы говорили о домене и о том, насколько важно создавать модель, которая выражает этот домен. Мы дали несколько рекомендаций по техникам, которые стоит использовать, чтобы получить полезную модель. Модель должна быть тесно связана с доменом, из которого она выросла. Мы также говорили, что проектирование кода должно строиться вокруг модели, а саму модель нужно улучшать, опираясь на решения по дизайну. Проектирование без модели может привести к ПО, которое не соответствует домену, которому служит и может вести себя не так, как ожидается. Моделирование без обратной связи от проектирования и без участия разработчиков приводит к модели, которую плохо понимают те, кому её реализовывать, и которая может не подходить под используемые технологии.

В процессе проектирования и разработки нам время от времени нужно останавливаться и смотреть на код. Возможно, пришло время для рефакторинга. Рефакторинг это переработка структуры кода, чтобы сделать его лучше, не меняя поведение приложения. Обычно рефакторинг делают маленькими, контролируемыми шагами, максимально аккуратно, чтобы не сломать функциональность и не занести баги. В конце концов, цель рефакторинга — улучшить код, а не ухудшить. Автоматические тесты очень помогают убедиться, что мы ничего не сломали.

Есть много способов делать рефакторинг кода. Есть даже паттерны рефакторинга. Такие паттерны описывают автоматизированный подход к рефакторингу. На основе этих паттернов есть инструменты, которые заметно упрощают жизнь разработчику по сравнению с тем, как было раньше. Без таких инструментов рефакторинг может быть очень сложным. Этот вид рефакторинга в большей степени про сам код и его качество.

Существует другой тип рефакторинга, связанный с доменом и его моделью. Иногда появляется новое понимание домена: что-то становится яснее или обнаруживается связь между двумя элементами. Всё это следует включать в проектирование через рефакторинг. Очень важно, чтобы код был выразительным, его было легко читать и понимать. Читая код, должно быть понятно не только, что делает код, но и почему он это делает. Только тогда код действительно сможет передать сущность модели.

Технический рефакторинг, тот, что основан на паттернах, можно организовать и выстроить как процесс. Рефакторинг на пути к более глубокому пониманию так делать нельзя. Для него невозможно создать паттерны. Сложность модели и разнообразие моделей не дают нам возможности подходить к моделированию механически. Хорошая модель — результат глубокого мышления, озарений, опыта и чутья.

Одно из первых, чему нас учат в моделировании это читать бизнес требования и искать существительные и глаголы. Существительные превращают в классы, а глаголы в методы. Это упрощение, и оно приведёт к поверхностной модели. В начале любой модели не хватает глубины, но мы должны через рефакторинг двигать модель к всё более глубокому пониманию

Проектирование должно быть гибким. Жёсткое проектирование сопротивляется рефакторингу. С кодом, который изначально писали без оглядки на гибкость, трудно работать. Когда требуется изменение, видно, как код сопротивляется и вещи, которые должны бы рефакториться легко, начинают отнимать много времени.

Использование проверенного набора базовых строительных блоков вместе с единым языком вносит в разработку немного здравого смысла. Но при этом остаётся задача действительно найти точную модель, которая улавливает тонкие нюансы, важные для экспертов домена и помогает прийти к практичному проектному решению. Модель, которая отбрасывает поверхностное и удерживает существенное это глубокая модель. Такая модель делает ПО более созвучным тому, как мыслят эксперты домена и более отзывчивым к потребностям пользователя.

Традиционно рефакторинг описывают как преобразования кода по техническим причинам. Но рефакторинг может быть вызван и более глубоким пониманием домена и соответствующим уточнением модели или её выражения в коде.
Сложные доменные модели редко появляются иначе, чем через итеративный процесс рефакторинга, при тесном взаимодействии экспертами домена с разработчиками, которым действительно важно разобраться в домене.

### Вытащить ключевые понятия на свет

Рефакторинг делают маленькими шагами. Результат это также серия небольших улучшений. Бывает, что множество мелких изменений почти не добавляет ценности проектированию, а бывает, что несколько изменений дают огромный эффект. Это Прорыв.

Мы начинаем с грубой, поверхностной модели. Затем уточняем её и проектирование на основе более глубокого знания домена и лучшего понимания важных аспектов предметной области. Мы добавляем в неё новые понятия и абстракции. Затем делаем рефакторинг проектирования. Каждое уточнение добавляет проектированию ясности. А это, в свою очередь, создаёт предпосылки для Прорыва.

Прорыв часто связан со сменой мышления, с тем, как мы начинаем видеть модель. Это источник заметного прогресса в проекте, но у него есть и обратная сторона. Прорыв может означать большой объём рефакторинга. А это время и ресурсы, которых нам, кажется, всегда не хватает. Это ещё и риск, потому что масштабный рефакторинг может непреднамеренно изменить поведение приложения.

Чтобы прийти к Прорыву, нужно явно выделить скрытые понятия. Когда мы общаемся с экспертами предметной области, мы обмениваемся большим количеством идей и знаний. Часть понятий попадает в Единый язык, но часть поначалу остаётся незамеченной. Это скрытые понятия, которые используют, чтобы объяснять другие понятия, уже вошедшие в модель. В процессе уточнения модели и проектирования некоторые из этих скрытых понятий начинают привлекать внимание. Мы обнаруживаем, что некоторые из них играют ключевую роль в проектировании. В этот момент соответствующие понятия нужно сделать частью модели явно: выделить для них классы и связи. Когда это происходит, у нас появляется шанс на Прорыв.

Скрытые понятия не должны оставаться скрытыми. Если это понятия предметной области, они должны присутствовать в модели и в проектировании. Как их распознать? Первый способ обнаружить скрытые понятия это прислушиваться к языку. язык, которым мы пользуемся во время моделирования и проектирования, содержит много информации о предметной области. В начале её может быть немного или часть информации может использоваться неправильно. Некоторые понятия могут быть поняты не до конца или даже поняты неверно. Это нормальная часть освоения новой предметной области. Но по мере того как мы выстраиваем Единый язык, ключевые понятия начинают в него попадать. И именно там стоит начинать искать скрытые понятия.

Иногда отдельные части проектирования могут быть не слишком ясными. Бывает набор связей, из-за которого трудно проследить ход выполнения. Или методы делают что-то настолько сложное, что это тяжело понять. Это шероховатости в проектировании. В таких местах хорошо искать скрытые понятия. Скорее всего, чего-то не хватает. Если в пазле отсутствует ключевое понятие, остальным приходится брать на себя его работу. Из-за этого некоторые объекты раздуваются, получая поведение, которое им не положено. Ясность проектирования от этого страдает. Попробуйте увидеть, нет ли здесь отсутствующего понятия. Если нашли, то сделайте его явным. Проведите рефакторинг проектирования, чтобы оно стало проще и гибче.

В процессе накопления знаний можно столкнуться с противоречиями. То, что говорит один эксперт предметной области, может казаться противоположным тому, на чём настаивает другой. Одно требование может выглядеть противоречащим другому. Часть таких противоречий на деле не противоречия, а разные способы смотреть на одно и то же или просто неточность в объяснениях. Мы должны пытаться эти противоречия согласовывать. Иногда это помогает проявить важные понятия. Даже если нет, всё равно важно сохранять ясность.

Ещё один очевидный способ вытащить понятия модели это опираться на литературу по предметной области. По почти любой теме написаны книги. В них много знаний о соответствующих предметных областях. Обычно книги не предлагают готовых моделей для тех доменов, которые описывают. Информацию из них нужно обработать, отфильтровать и уточнить. Но всё равно знания из книг ценны и дают глубокий взгляд на предметную область.

Есть и другие понятия, которые очень полезно делать явными: Ограничение, Процесс и Спецификация. Ограничение это простой способ выразить инвариант. Что бы ни происходило с данными объекта, инвариант сохраняется. Это достигается тем, что логика инварианта выносится в Ограничение. Далее простой пример. Его цель объяснить понятие, а не предложить рекомендуемый подход для похожего случая.

![](../img/Image18.png)

Мы можем добавлять книги на Bookshelf (шкаф), но не должны добавлять больше, чем позволяет его capacity (ёмкость). Это можно рассматривать как часть поведения Bookshelf, как в следующем Java коде.

```java
public class Bookshelf {
    private int capacity = 20;
    private Collection content;

    public void add(Book book) {
        if(content.size() + 1 <= capacity) {
            content.add(book);
        } else {
            throw new IllegalOperationException(
            “The bookshelf has reached its limit.”);
        }
    }
}
```

Мы можем сделать рефакторинг кода, выделив Ограничение в отдельный метод.

```java
public class Bookshelf {
    private int capacity = 20;
    private Collection content;

    public void add(Book book) {
        if(isSpaceAvailable()) {
            content.add(book);
        } else {
            throw new IllegalOperationException(
            “The bookshelf has reached its limit.”);
        }
    }

    private boolean isSpaceAvailable() {
        return content.size() < capacity;
    }
}
```

Вынесение Ограничения в отдельный метод имеет преимущество: оно делает его явным. Такой код легко читать, и всем будет видно, что метод add() подчиняется этому ограничению. Кроме того, остаётся пространство для развития: если ограничение станет сложнее, в методы можно будет добавить больше логики.

Процессы обычно выражают в коде процедурами. Мы не будем использовать процедурный подход, поскольку работаем в объектно-ориентированном языке, поэтому нам нужно выбрать объект для процесса и добавить ему поведение. Лучший способ реализовать процессы это использовать Сервис. Если есть разные способы выполнить процесс, можно инкапсулировать алгоритм в объект и применить паттерн Стратегию. Не все процессы нужно делать явными. Если Единый язык прямо называет соответствующий процесс, значит пришло время для явной реализации.

Последний способ сделать понятия явными, который мы здесь рассматриваем это Спецификация. Проще говоря, Спецификация используется, чтобы проверить объект и понять, удовлетворяет ли он определённому критерию.

В доменном слое находятся бизнес правила, которые применяются к Сущностям и Объектам-значениям. Эти правила обычно размещают в тех объектах, к которым они относятся. Часть таких правил это просто набор вопросов, на которые ответ «да» или «нет». Такие правила можно выразить серией логических операций с итоговым Булевым значением. Один из примеров — проверка объекта Customer (Клиент) на то, подходит ли он для получения кредита. Правило можно оформить как метод с именем isEligible() (имеет право) и поместить в объект Customer. Но это правило не является простым методом, который работает только с данными Customer. Чтобы вычислить правило, нужно проверять реквизиты клиента, смотреть, платил ли он долги в прошлом, есть ли у него непогашенные кредиты, и так далее. Такие бизнес правила могут быть большими и сложными, раздувая объект до состояния, когда он перестаёт выполнять свою исходную роль. В этот момент может возникнуть соблазн перенести всё правило на слой приложения, потому что кажется, будто оно выходит за рамки доменного слоя. На самом деле это время для рефакторинга.

Правило следует инкапсулировать в отдельный объект, который станет Спецификацией для Customer, и оставить его в доменном слое. Новый объект будет содержать серию методов возвращающих Булево значение, которые проверяют, подходит ли конкретный объект Customer для кредита. Каждый метод играет роль небольшого теста, а все методы вместе дают ответ на исходный вопрос. Если бизнес правило не собрано в одном объекте Спецификации, соответствующий код в итоге расползётся по нескольким объектам и станет несогласованным.

Паттерн Спецификация используют, чтобы проверять объекты: удовлетворяют ли они какой-то потребности или готовы ли для определённой цели. Также Спецификацию можно использовать, чтобы выбрать объект из коллекции или как условие при создании объекта.

Часто одна Спецификация проверяет, выполняется ли простое правило, а затем несколько таких спецификаций объединяют в составную, которая выражает сложное правило, например так:

```java
Customer customer = customerRepository.findCustomer(customerIdentiy);
…
Specification customerEligibleForRefund = new Specification(
    new CustomerPaidHisDebtsInThePast(), 
    new CustomerHasNoOutstandingBalances());

if(customerEligibleForRefund.isSatisfiedBy(customer) {
    refundService.issueRefundTo(customer);
}
```

Проверять простые правила проще, и уже по одному чтению этого кода очевидно, что означает customer eligible for refund (клиент имеет право на возврат).