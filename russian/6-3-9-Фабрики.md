### Фабрики  

Сущности и Агрегаты часто бывают большими и сложными — слишком сложными, чтобы создавать их в конструкторе корневой сущности. Более того, попытка собирать сложный агрегат прямо в его конструкторе противоречит тому, как это обычно происходит в самой предметной области, где одни вещи создаются другими (например, электронику собирают на конвейере). Это всё равно что заставить принтер собрать самого себя.

Когда клиентский объект хочет создать другой объект, он вызывает его конструктор и, возможно, передаёт какие-то параметры. Но когда построение объекта трудоёмкий процесс, его создание требует большого знания о внутренней структуре объекта, о связях между входящими в него объектами и о правилах, которые к ним применяются. Это означает, что каждый клиент этого объекта будет обладать специфическим знанием о том объекте, который он собирает. Это ломает инкапсуляцию доменных объектов и Агрегатов. Если при этом клиент относится к слою приложения, то часть доменного слоя оказывается вынесенной наружу, и всё проектирование начинает разваливаться. В реальной жизни это выглядит так, будто нам выдали пластик, резину, металл, кремний, и мы сами собираем себе принтер. Это возможно, но действительно ли это того стоит?

Создание объекта само по себе может быть серьёзной операцией, но сложные операции сборки не относятся к ответственности создаваемых объектов. Смешивание таких обязанностей может привести к неуклюжим решениям, которые трудно понять.

Поэтому нужно ввести новое понятие — такое, которое помогает инкапсулировать процесс сложного создания объектов. Оно называется Фабрика (Factory). Фабрики используются для того, чтобы инкапсулировать знания, необходимые для создания объектов, и особенно полезны при создании Агрегатов. Когда создаётся корень Агрегата, вместе с ним создаются все объекты, входящие в Агрегат, и обеспечивается соблюдение всех инвариантов.

Важно, чтобы процесс создания был атомарным. Если он не атомарен, существует риск частичного создания некоторых объектов, оставляя их в неопределённом состоянии. Это особенно актуально для Агрегатов. Когда корень создаётся, необходимо, чтобы все объекты, подпадающие под инварианты, также были созданы. Иначе инварианты не могут быть соблюдены. Для неизменяемых Объектов-значений это означает, что все атрибуты инициализируются в валидном состоянии. Если объект не может быть создан корректно, должно быть выброшено исключение, гарантируя, что наружу не будет возвращено недопустимое значение. 

Поэтому, перенесите ответственность за создание экземпляров сложных объектов и Агрегатов в отдельный объект, который может не иметь ответственности в доменной модели, но всё равно является частью проектирования домена. Предоставьте интерфейс, инкапсулирующий всю сложную сборку и не требующий от клиента ссылаться на конкретные классы создаваемых объектов. Создавайте агрегаты целиком, как единое целое, обеспечивая соблюдение их инвариантов.

Существует несколько паттернов проектирования, которые используют для реализации фабрик. Книга «Design Patterns» Gamma и соавторов подробно их описывает и, среди прочего, рассматривает два таких паттерна: Фабричный метод и Абстрактная фабрика. Мы не будем разбирать эти паттерны с точки зрения проектирования, а посмотрим на них с точки зрения доменного моделирования.  

Factory Method — это метод объекта, который содержит и скрывает знания, необходимые для создания другого объекта. Это очень полезно, когда клиенту нужно создать объект, который принадлежит Агрегату. Решение в том, чтобы добавить метод в корень Агрегата, который берёт на себя создание объекта, обеспечивает соблюдение всех инвариантов и возвращает ссылку на этот объект или его копию.

![](../img/Image12.png)

Контейнер содержит компоненты, и они имеют определённый тип. Необходимо, чтобы при создании такого компонента он автоматически становился частью контейнера. Клиент вызывает метод createComponent(Type t) у контейнера. Контейнер создаёт новый компонент. Конкретный класс компонента определяется на основе его типа. После создания компонент добавляется в коллекцию компонентов, содержащихся в контейнере, и его копия возвращается клиенту.

Бывают случаи, когда построение объекта сложнее, или когда создание одного объекта предполагает создание целой последовательности объектов. Например, при создании Агрегата. Скрыть внутренние детали сборки Агрегата можно, вынеся это в отдельный объект Фабрики, специально предназначенный для этой задачи. Рассмотрим пример программного модуля, который вычисляет маршрут, по которому может проехать автомобиль от точки отправления до пункта назначения, при заданном наборе ограничений. Пользователь входит на веб-сайт, на котором работает приложение, и задаёт одно из следующих ограничений: самый короткий маршрут, самый быстрый маршрут, самый дешёвый маршрут. Созданные маршруты могут быть дополнены информацией о пользователе, которую нужно сохранить, чтобы потом их можно было получить, когда клиент снова войдёт в систему.

![](../img/Image13.png)

Route ID generator используется для создания уникальной идентичности каждого маршрута, необходимой для Сущности.  

При создании фабрики мы вынуждены нарушать инкапсуляцию объекта, и делать это нужно осторожно. Всякий раз, когда в объекте что-то меняется и это влияет на правила построения или на какие-то инварианты, нужно убедиться, что фабрика обновлена и поддерживает новое условие. Фабрики тесно связаны с объектами, которые они создают. Это может быть слабостью, но может быть и силой. Агрегат содержит набор объектов, которые тесно связаны между собой. Создание корня связано с созданием остальных объектов в Агрегате. Должна существовать некоторая логика, которая собирает Агрегат воедино. Эта логика естественным образом не принадлежит ни одному из объектов, потому что она относится к созданию других объектов. Поэтому уместно использовать специальный класс Фабрики, которому поручена задача создавать Агрегат целиком и который будет содержать правила, ограничения и инварианты, необходимые для того, чтобы Агрегат был валидным. Сами объекты при этом останутся простыми и будут выполнять свою конкретную задачу без нагромождения сложной логики сборки.

Фабрики Сущностей и Фабрики Объектов-значений различаются. Объекты-значения обычно неизменяемы, и все необходимые атрибуты должны быть сформированы в момент создания. Когда объект создан, он должен быть валидным и окончательным. Он не будет меняться. Сущности не являются неизменяемыми. Их можно изменять позже, задавая некоторые атрибуты, при условии, что соблюдаются все инварианты. Ещё одно отличие связано с тем, что сущностям нужна идентичность, тогда как объектам-значениям — нет.

Бывают случаи, когда Фабрика не нужна и достаточно простого конструктора. Используйте конструктор, когда:

- Создание несложное.
- Создание объекта не предполагает создания других объектов, и все нужные атрибуты передаются через конструктор.
- Клиенту важна реализация, возможно он хочет выбрать используемую стратегию.
- Класс и есть тип. Иерархии нет, поэтому не нужно выбирать из набора конкретных реализаций.

Ещё одно наблюдение: Фабрики должны либо создавать новые объекты с нуля, либо восстанавливать объекты, которые уже существовали и были сохранены в базе данных. Возврат сущностей из базы данных обратно в память это совершенно иной процесс, чем создание новых. Одно очевидное отличие, при восстановлении объекту не нужна новая идентичность. Она у него уже есть. Нарушения инвариантов тоже обрабатываются по-разному. Когда новый объект создаётся с нуля, любое нарушение инвариантов приводит к исключению. С объектами, восстановленными из базы данных, так поступить нельзя. Их нужно как-то “починить”, чтобы они могли работать, иначе произойдёт потеря данных.