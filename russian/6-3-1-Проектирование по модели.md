## Проектирование по модели 

Предыдущие главы подчёркивали важность подхода к разработке программного обеспечения, ориентированного на бизнес‑домен. Мы говорили, что фундаментально важно создать модель, глубоко укоренённую в домене, и которая должна точно отражать основные концепции домена. Единый язык должен полностью использоваться в процессе моделирования, чтобы облегчить коммуникацию между специалистами по программному обеспечению и экспертами домена, а также выявить ключевые концепции домена, которые следует использовать в модели. Цель этого процесса — получить хорошую модель. Следующий шаг — реализовать модель в коде. Это не менее важная фаза разработки. Даже создав отличную модель, но не сумев корректно перенести её в код, мы в итоге получим ПО сомнительного качества.

Бывает так, что аналитики программного обеспечения работают с экспертами бизнес‑домена месяцами, выявляют фундаментальные элементы домена, подчёркивают их взаимосвязи и создают корректную модель, точно отражающую домен. Затем эту модель передают разработчикам. Разработчики смотрят на неё и обнаруживают, что некоторые концепции или отношения из модели невозможно корректно выразить в коде. Поэтому они используют модель как исходный источник вдохновения, но создают собственные проектные решения, заимствующие некоторые идеи из модели и добавляющий свои. Процесс разработки продолжается, в код добавляются новые классы, расширяя разрыв между исходной моделью и конечной реализацией. Хороший конечный результат не гарантирован. Хорошие разработчики могут собрать продукт, который работает, но выдержит ли он испытание временем? Будет ли он легко расширяемым? Будет ли он легко поддерживаемым?  

Любой домен может быть выражен множеством моделей, и любую модель можно реализовать в коде различными способами. Для каждой конкретной задачи может существовать более одного решения. Какое выбрать? Наличие аналитически корректной модели не означает, что её можно напрямую выразить в коде. Или её реализация может нарушать некоторые принципы проектирования программного обеспечения, что нежелательно. Важно выбрать модель, которую можно легко и точно перенести в код. Основной вопрос здесь: как подойти к переходу от модели к коду?  

Одной из рекомендуемых техник проектирования является так называемая аналитическая модель (analysis model), рассматриваемая как отдельная от проектирования кода и обычно выполняемая другими людьми. Аналитическая модель — результат анализа предментной области, не учитывающую программное обеспечение используемое для реализации. Такая модель используется для понимания домена. Формируется определённый уровень знаний, и полученная модель может быть аналитически корректной. На этом этапе программное обеспечение не учитывается, поскольку считается запутывающим фактором. Эта модель попадает к разработчикам, которым предстоит проектировать решение. Но раз модель строилась без оглядки на принципы проектирования, для этой цели она, скорее всего, подходит плохо. Разработчикам приходится либо адаптировать её, либо создавать отдельную модель, уже ориентированную на реализацию. И в этот момент соответствие между моделью и кодом теряется. В итоге, как только начинается программирование, аналитические модели обычно довольно быстро забрасывают.

Одна из главных проблем этого подхода — аналитики не могут предвидеть некоторые дефекты своей модели и тонкости домена. Аналитики могут слишком детализировать некоторые компоненты модели и недостаточно детализировать другие. Очень важные детали обнаруживаются в процессе проектирования и реализации. Модель, правдиво отражающая домен, может оказаться проблемной с точки зрения сохранения объектов или неприемлемой производительности. Разработчики будут вынуждены принимать решения самостоятельно и менять проектные решения, чтобы решить реальную проблему, не учтённую при создании модели. В результате они создают решение, которое уходит в сторону от исходной модели, делая саму модель всё менее релевантной.

Если аналитики работают независимо, они в конечном итоге создадут модель. Когда эта модель передаётся проектировщикам системы, часть знаний аналитиков о домене и модели теряется. Даже если модель выражена диаграммами и текстом, велика вероятность, что проектировщики не уловят весь её смысл, не восстановят некоторые связи между объектами или не поймут их поведение. В модели есть детали, которые трудно выразить в диаграмме и могут быть не полностью представлены даже в тексте. Разработчикам будет сложно их понять. В некоторых случаях они сделают предположения о предполагаемом поведении, и могут ошибиться, что приведёт к некорректной работе программы.  

Аналитики проводят закрытые встречи, на которых они много обсуждают предметную область и активно обмениваются знаниями. Они создают модель, которая должна содержать всю эту информацию в сжатой форме, а разработчики должны усвоить её, читая предоставленные документы. Было бы гораздо продуктивнее, если бы разработчики могли присоединяться к аналитическим встречам и получить чёткое и полное представление о домене и модели до начала проектирования кода.  

Лучший подход — тесно связать доменное моделирование предметной области и проектирование. Модель следует строить с оглядкой на будущее программное воплощение и проектные ограничения. Разработчики должны быть включены в процесс моделирования. Основная идея — выбрать модель, которую можно адекватно выразить в программном обеспечении, чтобы процесс проектирования и реализация были прямым продолжением модели. Тесная связь кода с моделью придаёт коду смысл, а модель остаётся живой и полезной.

Вовлечение разработчиков обеспечивает обратную связь. Это гарантирует, что модель можно реализовать в программном обеспечении. Если что‑то неверно, это выявляется на ранней стадии, и проблему можно легко исправить.  

Те, кто пишет код, должны хорошо знать модель и чувствовать ответственность за её целостность. Они должны понимать, что изменение кода подразумевает изменение модели; иначе они будут рефакторить код до такой степени, что он перестанет выражать исходную модель. Если аналитик отделён от процесса реализации, он быстро потеряет интерес к ограничениям, вводимым разработкой. В результате получаем непрактичную модель.  

Любой технический специалист, вносящий вклад в модель, должен хотя бы немного работать с кодом, независимо от своей основной роли в проекте. Каждый, кто отвечает за изменение кода, должен научиться выражать модель через код. Каждый разработчик должен участвовать в обсуждении модели и иметь контакт с экспертами домена. Те, кто вносит вклад другими способами, должны сознательно привлекать тех, кто работает с кодом, к живому обмену идеями о модели через Единый язык.  

Если проектирование, или какая-то его центральная часть, не отображается в доменной модели, то такая модель почти бесполезна, а корректность программного обеспечения ставится под сомнение. При этом сложные сопоставления между моделями и проектными конструкциями трудно понять и на практике, невозможно поддерживать при изменении проекта. В итоге между анализом и проектированием появляется разрушительный разрыв: знания, полученные в одном из этих видов деятельности, не подпитывают другой.

Разработайте часть программной системы так, чтобы она буквально отражала доменную модель, чтобы сопоставление было очевидным. Пересмотрите модель и модифицируйте её так, чтобы её было естественно реализовать в ПО, одновременно стремясь отразить более глубокое понимание домена. Требуйте единой модели, которая хорошо служит обеим целям и поддерживает свободный разговор на Едином языке.

Берите из модели терминологию, используемую при проектировании, и базовое распределение ответственностей. Код становится выражением модели, поэтому изменение кода может означать изменение модели. Соответственно, последствия такого изменения должны расходиться волной по всем остальным видам деятельности в проекте.

Тесная привязка реализации к модели обычно требует инструментов разработки и языков, поддерживающих парадигму моделирования, таких как объектно-ориентированное программирование.  

Объектно-ориентированное программирование (ООП) подходит для реализации модели, потому что обе основываются на одной парадигме. ООП предоставляет классы объектов и связи между классами, экземпляры объектов и обмен сообщениями между ними. языки ООП позволяют создавать прямые соответствия между объектами модели и их программными представлениями.  

Процедурный языки предлагают ограниченную поддержку проектированию по модели (model‑driven design). В таких языках нет выразительных средств, необходимых для реализации ключевых частей модели. Некоторые утверждают, что ООП можно реализовать на процедурном языке, например C, и действительно часть функциональности можно воспроизвести таким способом. Объекты могут имитировать структурами данных. Но такие структуры не содержат поведения объекта, которое нужно добавлять отдельно в виде функций. Смысл этих структур не выражен в коде явно и существует главным образом в голове разработчиков. Программа, написанная на процедурном языке, обычно воспринимается как набор функций, вызывающих друг друга и совместно достигающих результата. Такой программе трудно “упаковывать” концептуальные связи, поэтому соответствие между доменом и кодом становится сложно построить и поддерживать.  

Некоторые предметные области, например математика, можно довольно просто моделировать и реализовывать в процедурном стиле: многие математические теории естественно выражаются через вызовы функций и структуры данных, потому что по сути речь идёт о вычислениях. Более сложные домены — это не просто набор абстрактных вычислительных концепций. Их нельзя свести к набору алгоритмов, поэтому процедурные языки хуже справляются с задачей выражения соответствующих моделей. По этой причине процедурное программирование не рекомендуется для разработки, основанной на модели.