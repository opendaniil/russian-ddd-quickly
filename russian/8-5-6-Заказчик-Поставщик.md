### Заказчик-Поставщик

Иногда у двух подсистем складываются особые отношения: одна из них сильно зависит от другой. Они живут в разных Ограниченных контекстах, и результат обработки одной подсистемы используется как входные данные для другой. При этом Общее ядро (Shared Kernel) между ними нет, потому что оно может быть концептуально неправильным, или двум подсистемам может быть технически невозможно разделять общий код. В такой ситуации между подсистемами устанавливаются отношения Заказчик–Поставщик (Customer–Supplier).

Вернёмся к предыдущему примеру. Ранее мы обсуждали модели в e-commerce приложении, где есть контексты отчётности и сообщений. Мы уже говорили, что для всех этих контекстов правильнее завести отдельные модели, потому что единая модель стала бы постоянным узким местом и поводом для трений в разработке. Допустим, мы согласились на раздельные модели. Какими тогда должны быть отношения между подсистемой веб-покупок и подсистемой отчётности? Общее ядро (Shared Kernel) здесь не выглядит хорошим вариантом. Скорее всего подсистемы будут реализованы на разных технологиях: одна это чистый веб-интерфейс, другая может быть толстым GUI-приложением. Даже если отчётность тоже сделать веб-приложением, ключевые понятия их моделей всё равно различаются. Пересечения возможны, но их недостаточно, чтобы оправдать Общее ядро. Значит, идём другим путём. С другой стороны, подсистема интернет-магазина вообще не зависит от подсистемы отчётности. Пользователи интернет-магазина это веб-клиенты, которые просматривают товары и оформляют заказы. Все данные о клиентах, товарах и заказах сохраняются в базе данных. И на этом всё: интернет-магазин не интересуется тем, что дальше будут делать с этими данными. А вот подсистема отчётности, наоборот, очень заинтересована в данных, которые сохраняет интернет-магазин, и прямо нуждается в них. Более того, ей нужна дополнительная информация, чтобы оказывать свои отчётные сервисы. Например, покупатель мог положить товар в корзину и убрать его до оформления заказа. Или мог заходить на одни ссылки чаще, чем на другие. Для интернет-магазина такая информация не имеет значения, а для отчётности она может быть критичной. Следовательно, подсистема поставщика должна поддержать требования, которые нужны подсистеме заказчика. Это одна из связей между двумя подсистемами.

Ещё одно требование связано с базой данных, точнее с её схемой. Оба приложения будут работать с одной и той же базой. Если бы к базе обращалась только подсистема интернет-магазина, схему можно было бы менять в любой момент под её нужды. Но к базе обращается и подсистема отчётности, поэтому ей нужна хотя бы относительная стабильность и предсказуемость схемы. Невозможно представить, что схема базы данных вообще не будет меняться в процессе разработки. Для интернет-магазина это не проблема, а для отчётности точно проблема. Командам придётся постоянно общаться, вероятно вместе работать с базой и договариваться, когда именно делать изменения. Для подсистемы отчётности это становится ограничением: их команда предпочла бы быстро внести правку и двигаться дальше, а не ждать интернет-магазин. Если у команды интернет-магазина есть право вето, она может накладывать ограничения на изменения схемы, тем самым тормозя работу команды отчётности. Если же команда интернет-магазина может действовать полностью самостоятельно, рано или поздно она нарушит договорённости и внесёт изменения, к которым команда отчётности не готова. Этот паттерн хорошо работает, когда обе команды находятся под единым руководством: так проще принимать решения и снижать трения.

В такой ситуации нужно формализовать взаимодействие. Команда отчётности должна выступать заказчиком, а команда интернет-магазина поставщиком. Команды должны встречаться регулярно и по мере необходимости и вести диалог в режиме заказчик–поставщик. Команда заказчика формулирует свои требования, а команда поставщика строит планы с учётом этих требований. В итоге все требования заказчика должны быть закрыты, но сроки и порядок реализации определяет поставщик. То, что критично, делается раньше, а менее важное можно отложить. Кроме того, заказчику понадобятся входные данные, контекст и экспертиза со стороны поставщика. Поток здесь в основном однонаправленный, но в таких связках без этого не обойтись.

Интерфейс между двумя подсистемами должен быть определён предельно точно. Нужно создать набор тестов на соответствие и использовать его, чтобы в любой момент проверять, соблюдаются ли требования к интерфейсу. Тогда команда поставщика сможет свободнее работать над проектированием, потому что интерфейсные тесты будет сигнализировать, как только возникает проблема.

Установите чёткие отношения заказчик/поставщик между двумя командами. На сессиях планирования команда заказчика должна выступать заказчиком по отношению к команде поставщика. Согласовывайте и закладывайте в план работы по требованиям заказчика так, чтобы всем были понятны обязательства и сроки.

Совместно разработайте автоматизированные приёмочные тесты, которые проверяют ожидаемый интерфейс. Добавьте эти тесты в тестовый набор команды поставщика и запускайте их как часть Непрерывной интеграции (CI). Такое тестирование позволит команде поставщика вносить изменения без страха побочных эффектов для приложения команды заказчика.