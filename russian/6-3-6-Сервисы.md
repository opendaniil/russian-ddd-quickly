### Services  

Когда мы анализируем домен и пытаемся определить основные объекты модели, мы обнаруживаем, что некоторые аспекты домена трудно отобразить в виде объектов. Обычно об объекте думают так: у него есть атрибуты, внутреннее состояние, которым он управляет, и поведение. Когда мы развиваем Единый язык, ключевые понятия домена появляются в языке, и существительные этого языка легко проецируются на объекты. Глаголы языка, связанные со своими существительными, становятся частью поведения этих объектов. Но в домене есть действия, некоторые глаголы, которые, похоже, не принадлежат ни одному объекту. Они выражают важное поведение домена, поэтому их нельзя игнорировать или просто “впихнуть” в какие-то Сущности или Объекты-значения. Если добавить такое поведение в объект, это испортит объект: он начнёт отвечать за функциональность, которая ему не принадлежит. Тем не менее, пользуясь объектно-ориентированным языком, мы всё равно должны выразить такое поведения к объекту. Нельзя просто оставить отдельную функцию саму по себе. Часто такое поведение охватывает несколько объектов, иногда разных классов. Например, перевод денег со счёта на счёт: где должна жить эта операция — в счёте-отправителе или в счёте-получателе? В обоих вариантах она выглядит неуместно.  

Когда такое поведение обнаружено в домене, лучшая практика — объявить его как Сервис (Service). Такой объект не имеет внутреннего состояния, а его цель — просто предоставить функциональность для домена. Помощь, предоставляемая Сервисом, может быть значительной, и Сервис может группировать связанную функциональность, обслуживая Сущность и Объект-значение.Объявлять Сервис лучше явно, потому что так понятнее, где живёт эта логика и за что отвечает. Если же запихнуть её в Сущность или Объект-значение, эти объекты начинают выглядеть “про всё сразу”, и становится неясно, что они на самом деле представляют.

Сервис выступает как интерфейс, предоставляющий операции. Сервис часто встречаются в технических фреймворках, но их можно использовать и в доменном слое. Сервис не про “объект, который что-то делает сам с собой”, а про операции, выполняемые над другими объектами или для них. Таким образом, Сервис обычно становится точкой соединения для множества объектов. Это одна из причин, почему поведение, которому естественно жить в Сервисе, не стоит запихивать в доменные объекты. Если разнести такую функциональность по Сущностям и Объектам-значениям, между ними быстро появится плотная сеть связи: одни объекты будут тянуться к другим, чтобы выполнить операцию “для них” или “над ними”. Высокая связанность многих объектов — признак плохого проектирования: код сложнее читать и понимать и, что важнее, его гораздо труднее менять.

Сервис не должен заменять операцию, которая обычно принадлежит доменным объектам. Не следует создавать Сервис для каждой требуемой операции. Но когда операция выделяется как важный концепт домена, для него следует создать Сервис. У Сервиса есть три характеристики:  

1. Операция Сервиса соответствует доменному понятию, которое не “ложится” естественно ни на Сущности или Объект-значению.  
2. Эта операция работает с другими объектами домена.
3. Операция не хранит состояние.  

Когда в домене есть важный процесс или преобразование, которое не является естественной ответственностью ни Сущности, ни Объекте-значении, выделите его в отдельный Сервис и зафиксируйте как самостоятельную операцию с ясным контрактом. Описывайте этот контракт на языке доменной модели и убедитесь, что имя операции является частью Единого языка и не храните в сервисе состояние.

При использовании Сервиса важно сохранять изоляцию доменного слоя. Легко запутаться между сервисами, принадлежащими доменному слою, и теми, что относятся к инфраструктуре. Также могут быть сервисы в слое приложения, что добавляет дополнительный уровень сложности. Такие сервисы ещё труднее отделить от их аналогов в доменном слое. Работая над моделью и на этапе дизайна, необходимо убедиться, что доменный уровень остаётся изолированным от остальных уровней.  

Обычно Сервисы домена и приложения строят поверх Сущности домена и Объектов-значений, предоставляя требуемую функциональность, непосредственно связанную с этими объектами. Поэтому нередко трудно решить, к какому слою отнести Сервис. Если выполняемая операция по смыслу относится к слою приложения, то Сервис следует разместить там. Если же операция относится к доменным объектам, строго привязана к предметной области и решает именно доменную задачу, то она должна находиться в доменном слое.

Рассмотрим практический пример, веб-приложение для формирования отчётов. Отчёты используют данные, хранящиеся в базе данных, и генерируются по шаблонам. Итоговый результат HTML-страница, которую пользователь видит в веб-браузере.

Слой пользовательского интерфейса (UI слой) реализуется в веб‑страницах и позволяет пользователю входить в систему, выбирать нужный отчёт и нажимать кнопку запроса. Слой приложения это тонкий слой между UI, доменом и инфраструктурой. Он взаимодействует с инфраструктурой базы данных при входе в систему и с доменным слоем при создании отчётов. Доменный слой содержит ядро домена, объекты, непосредственно связанные с отчётами. Два таких объекта — Отчёт и Шаблон, на основе которых формируются отчёты. Инфраструктурный слой поддерживает доступ к базе данных и файловой системе.  

Когда пользователь выбирает отчёт для создания, он фактически выбирает имя отчёта из списка имен — это строка reportID. Другие параметры (например, элементы отчёта, временной интервал) передаются, но для простоты будем рассматривать только reportID. Это имя передаётся через слой приложения в доменный слой. Доменный слой отвечает за создание и возврат отчёта по его имени. Поскольку отчёты строятся на шаблонах, можно создать Сервис, задача которого — получить шаблон, соответствующий reportID. Шаблон хранится в файле или в базе данных. Такую операцию неуместно размещать в самом объекте Отчёт, она не относится и к объекту Шаблон. Поэтому создаём отдельный Сервис, предназначенный для получения шаблона отчёта по его reportID. Это Сервис будет находиться в доменном слое и будет использовать файловую инфраструктуру, чтобы извлекать шаблон с диска.