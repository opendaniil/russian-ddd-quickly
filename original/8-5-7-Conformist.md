### Conformist

A Customer-Supplier relationship is viable when both teams are interested in the relationship. The customer is very dependent on the supplier, while the supplier is not. If there is a management to make this work, the supplier will pay the needed attention and will listen to the customer’s requests. If the management has not decided clearly how things are supposed to be between the two teams, or if there is poor management or lack of it, the supplier will slowly be more concerned about its model and design, and less interested in helping the customer. They have their own deadlines after all. Even if they are good people, willing to help the other team, the time pressure will have its say, and the customer team will suffer. This also happens when the teams belong to different companies. Communication is difficult, and the supplier’s company may not be interested to invest too much in this relationship. They will either provide sporadic help, or simply refuse to cooperate at all. The result is that the customer team is on its own, trying to do their best with the model and the design.

When two development teams have a Customer-Supplier relationship in which the supplier team has no motivation to provide for the customer team’s needs, the customer team is helpless. Altruism may motivate supplier developers to make promises, but they are unlikely to be fulfilled. Belief in those good intentions leads the customer team to make plans based on features that will never be available. The customer project will be delayed until the team ultimately learns to live with what it is given. An interface tailored to the needs of the customer team is not in the cards.

The customer team has few options. The most obvious one is to separate from the supplier and to be completely on their own. We will look at this later in the pattern Separate Ways. Sometimes the benefits provided by the supplier subsystem are not worth the trouble. It might be simpler to create a separate model, and design without having to give a thought to the supplier’s model. But this is not always the case.

Sometimes there is some value in the supplier’s model, and a connection has to be maintained. But because the supplier team does not help the customer team, the latter has to take some measures to protect itself from model changes performed by the former team. They will have to implement a translation layer which connects the two contexts. It is also possible that the supplier team’s model could be poorly conceived making its utilization awkward. The customer context can still make use of it, but it should protect itself by using an Anticorruption Layer which we will discuss later.

If the customer has to use the supplier team’s model, and if that is well done, it may be time for conformity. The customer team could adhere to the supplier team’s model, conforming entirely to it. This is much like the Shared Kernel, but there is an important difference. The customer team cannot make changes to the kernel. They can only use it as part of their model, and they can build on the existing code provided. There are many times when such a solution is viable. When somebody provides a rich component, and provides an interface to it, we can build our model including the respective component as it would be our own. If the component has a small interface, it might be better to simply create an adapter for it, and translate between our model and the component’s model. This would isolate our model, and we can develop it with a high degree of freedom.