### Customer-Supplier

There are times when two subsystems have a special relationship: one depends a lot on the other. The contexts in which those two subsystems exist are different, and the processing result of one system is fed into the other. They do not have a Shared Kernel, because it may not be conceptually correct to have one, or it may not even be technically possible for the two subsystems to share common code. The two subsystems are in a Customer-Supplier relationship.

Let’s return to a previous example. We talked earlier about the models involved in an e-commerce application, which includes reporting and messaging. We already said that it is much better to create separate models for all these contexts, because a single model would be a constant bottleneck and source of contention in the development process. Assuming that we agree to have separate models, what should be the relationships between the web shopping subsystem and the reporting one? The Shared Kernel does not seem to be the right choice. The subsystem will most likely use different technologies to be implemented. One is a pure browser experience, while the other could be a rich GUI application. Even if the reporting application is done using a web interface, the main concepts of the respective models are different. There might be some overlapping, but not enough to justify a Shared Kernel. So we choose to go on a different path. On the other hand, the e-shopping subsystem does not depend at all on the reporting one. The users of the e-shopping application are web customers who browse for merchandise and place orders. All the customer, merchandise and orders data is placed in a database. And that’s it. The e-shopping application is not really interested in what happens with the respective data. In the meantime, the reporting application is very interested in and needs the data saved by the e-shopping application. It also needs some extra information to carry out the reporting services it provides. The customers might put some merchandise in the basket, and then drop it before check out. The customers might visit some links more than others. This kind of information has no meaning for the e-shopping application, but it may mean a lot for the reporting one. Following that, the supplier subsystem has to implement some specifications which are needed by the customer subsystem. This is one connection between the two subsystems.

Another requirement is related to the database used, more exactly its schema. Both applications will make use of the same database. If the e-shopping subsystem was the only one to access the database, the database schema could be changed any time to reflect its needs. But the reporting subsystem needs to access the database too, so it needs some stability of its schema. It’s impossible to imagine that the database schema won’t change at all during the development process. This won’t represent a problem for the e-shopping application, but it will certainly be a problem for the reporting one. The two teams will need to communicate, probably they will have to work on the database together, and decide when the change is to be performed. This will act as a limitation for the reporting subsystem, because that team would prefer to swiftly do the change and move on with the development, instead of waiting on the e-shopping app. If the e-shopping team has veto rights, they may impose limits on the changes to be done to the database, hurting the reporting team’s activity. If the e-shopping team can act independently, they will break the agreements sooner or later, and implement some changes which the reporting team is not prepared for. This pattern works well when the teams are under the same management. This eases the decision making process, and creates harmony.

When we are faced with such a scenario, we should start acting. The reporting team should play the customer role, while the e-shopping team should play the supplier role. The two teams should meet regularly or upon request, and chat as a customer does with his supplier. The customer team should present its requirements, while the supplier team should make the plans accordingly. While all the customer team’s requirements will have to be met in the end, the timetable for doing that is decided by the supplier team. If some requirements are considered really important, they should be implemented sooner, while other requirements might be postponed. The customer team will also need input and knowledge to be shared by the supplier team. This process flows one way, but it is necessary in some cases.

The interface between the two subsystems needs to be precisely defined. A conformity test suite should be created and used to test at any time if the interface requirements are respected. The supplier team will be able to work more unreservedly on their design because the safe net of the interface test suite alerts them whenever it is a problem.

Establish a clear customer/supplier relationship between the two teams. In planning sessions, make the customer team play a customer role to the supplier team. Negotiate and budget tasks for customer requirements so that everyone understands the commitment and schedule. 

Jointly develop automated acceptance tests that will validate the interface expected. Add these tests to the supplier team’s test suite, to be run as part of its continuous integration. This testing will free the supplier team to make changes without fear of side effects to the customer team’s application.