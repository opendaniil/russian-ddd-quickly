### Entities  

There is a category of objects which seem to have an identity, which remains the same throughout the states of the software. For these objects it is not the attributes which matter, but a thread of continuity and identity, which spans the life of a system and can extend beyond it. Such objects are called Entities

OOP languages keep object instances in memory, and they associate a reference or a memory address for each object. This reference is unique for each object at a given moment of time, but there is no guarantee that it will stay so for an indefinite period of time. Actually the contrary is true. Objects are constantly moved out and back into memory, they are serialized and sent over the network and recreated at the other end, or they are destroyed. This reference, which stands as an identity for the running environment of the program, is not the identity we are talking about. If there is a class which holds weather information, like temperature, it is quite possible to have two distinct instances of the respective class, both containing the same value. The objects are perfectly equal and interchangeable with one another, but they have different references. They are not entities.

If we were to implement the concept of a Person using a software program, we would probably create a Person class with a series of attributes: name, date of birth, place of birth, etc. Are any of those attributes the identity of the person? Name cannot be the identity because there can be more people with the same name. We could not distinguish between to persons with the same name, if we were to take into account only their name. We canâ€™t use date of birth either, because there are many people born on the same day. The same applies to the place of birth. An object must be distinguished from other objects even though they might have the same attributes. Mistaken identity can lead to data corruption.

Consider a bank accounting sytem. Each account has its own number. An account can be precisely identified by its number. This number remains unchanged throughout the life of the system, and assures continuity. The account number can exist as an object in the memory, or it can be destroyed in memory and sent to the database. It can also be archived when the account is closed, but it still exists somewhere as long as there is some interest in keeping it around. It does not matter what representation it takes, the number remains the same. 

Therefore, implementing entities in software means creating identity. For a person it can be a combination of attributes: name, date of birth, place of birth, name of parents, current address. The Social Security number is also used in US to create identity. For a bank account the account number seems to be enough for its identity. Usually the identity is either an attribute of the object, a combination of attributes, an attribute specially created to preserve and express identity, or even a behavior. It is important for two objects with different identities to be to be easily distinguished by the system, and two objects with the same identity to be considered the same by the system. If that condition is not met, then the entire system can become corrupted. 

There are different ways to create a unique identity for each object. The ID could be automatically generated by a module, and used internally in the software without making it visible to the user. It can be a primary key in a database table, which is assured to be unique in the database. Whenever the object is retrieved from the database, its ID is retrieved and recreated in memory. The ID could be created by the user as it happens with the codes associated to airports. Each airport has a unique string ID which is internationally recognized and used by the travel agencies all over the world to identify airports in their travel schedules. Another solution is to use the attributes of the object to create the ID, and when that is not enough, another attribute can be added to help identify the respective object.

When an object is distinguished by its identity, rather than its attributes, make this primary to its definition in the model. Keep the class definition simple and focused on life cycle continuity and identity. Define a means of distinguishing each object regardless of its form or history. Be alert to requirements that call for matching objects by attributes. Define an operation that is guaranteed to produce a unique result for each object, possibly by attaching a symbol that is guaranteed unique. This means of identification may come from the outside, or it may be an arbitrary identifier created by and for the system, but it must correspond to the identity distinctions in the model. The model must define what it means to be the same thing.

Entities are important objects of a domain model, and they should be considered from the beginning of the modeling process. It is also important to determine if an object needs to be an entity or not, which is discussed in the next pattern. 